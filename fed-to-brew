#!/bin/bash
###############
# GET USER SETABLE VARIABLES
###############
SCRIPT_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
if [ -f ${SCRIPT_HOME}/fed-to-brew.conf ] ; then
  source ${SCRIPT_HOME}/fed-to-brew.conf
elif [ -f /etc/fed-to-brew.conf ] ; then
  source /etc/fed-to-brew.conf
else
  echo "Unable to find fed-to-brew.conf"
  echo "Expecting it to be ${SCRIPT_HOME}/fed-to-brew.conf or /etc/fed-to-brew.conf"
  echo "Exiting ..."
  exit 42
fi



###############
# SETUP and CHECK
###############
mkdir -vp ${WORKDIR}/{brew,fed,logs,map,results,tmp}
touch ${LOCK_FILE}
for this_dep in ${DEP_LIST}
do
  test_path="$(which ${this_dep} 2>/dev/null)"
  if [ "${test_path}" == "" ] ; then
    echo "${this_dep} was not found in your path."
    echo "${DEP_LIST} needs to be installed, and in your path."
    echo "exiting..."
    exit 1
  fi
done

###############
# Show help
###############
usage() {
  echo "Usage `basename $0` [command] <options> <[package 1] ... [package n]>" >&2
  echo >&2
  echo "Multipurpose tool to help tracking, syncing, building packages between" >&2
  echo "  fedora and brew." >&2
  echo >&2
  echo "Commands: (there must be one command, only one)" >&2
  echo "  --sync" >&2
  echo "    Sync package(s) from Fedora dist-git to Brew dist-git." >&2
  echo "    Only syncs from one git commit, does not do entire history." >&2
  echo "    Mandatory: --brew-branch" >&2
  echo "    Mandatory: --yaml OR --txt OR [package]" >&2
  echo "  --check" >&2
  echo "    Check the status of builds" >&2
  echo "  --double-check --dc --doublecheck" >&2
  echo "    Double check failed builds" >&2
  echo "  --check-modules --checkmodules" >&2
  echo "    Check the modules" >&2
  echo "  --build --rebuild" >&2
  echo "    Build package(s) in brew, if they have not already been built." >&2
  echo "    Will sync packages Fedora dist-git to Brew dist-git if needed." >&2
  echo "    Mandatory: --brew-branch" >&2
  echo "    Mandatory: --brew-dist" >&2
  echo "    Mandatory: --yaml OR --text OR [package]" >&2
  echo >&2
  echo "Options:" >&2
  echo "  -c --checkout [branch or hash]" >&2
  echo "    What to checkout of the fedora dist-git, can be branch or hash" >&2
  echo "    Warning: If using hash, only use one package" >&2
  echo "    Default: ${FED_GIT_CHECKOUT}" >&2
  echo "    Example branch: f26" >&2
  echo "    Example hash: 082464dc0d06d48d2f9c4d2110e8aafe4ef1c957" >&2
  echo "  -bb --brew-branch [branch]" >&2
  echo "    What brew branch to sync to" >&2
  echo "  -fd --fed-dist [dist]" >&2
  echo "    What to dist to pull the fedora source from" >&2
  echo "    Should only be needed if using a hash for checkout" >&2
  echo "    Default: ${FED_DIST}" >&2
  echo "    Example: f26" >&2
  echo "  -bd --brew-dist [dist]" >&2
  echo "    What dist tag to use when checking brew build status" >&2
  echo "    Example: .el7" >&2
  echo "  -m --message [message]" >&2
  echo "    Use a custom commit message for brew dist-git" >&2
  echo "  --text [file]" >&2
  echo "    Text file to use for list of packages" >&2
  echo "      Each package is on its own line in format <n-v-r>.src" >&2
  echo "      Example:acl-2.2.52-15.fc27.src" >&2
  echo "  --yaml [file]" >&2
  echo "    yaml file to use for list of packages" >&2
  echo "      Should be in the standard fedora module yaml file format." >&2
  echo "  --jobs [Integer]" >&2
  echo "    Number of jobs to do in parallel" >&2
  echo "  --no-remote --noremote" >&2
  echo "    Do not sync map ore results remotely.  Default: ${REMOTE} " >&2
  echo "  -v --verbose --debug" >&2
  echo "    Be verbose, for debugging" >&2
  echo "  --brew-check --brewcheck" >&2
  echo "    Check if we have a brew dist-git branch before doing work" >&2
  echo "  -h, --help" >&2
  echo "    Show this options menu" >&2
  echo >&2
  echo "Other:" >&2
  echo "  [package]" >&2
  echo "    If you want to do just a single file, list just the name" >&2
  echo "    Not applied if either --yaml or --text are used." >&2
  echo >&2
  popd &>/dev/null
  exit 1
}

###############
# Parse a yaml file
###############
function parse_yaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_-+.]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

###############
# Return the list of packages
###############
function get_packages {
  if [ "${YAML_FILE}" != "" ] ; then
    for line in $(parse_yaml ${YAML_FILE})
    do
      if echo $line | grep -q _ref= ; then
        this_name="$(echo $line | awk -F'__' '{print $4}')"
        fed_hash="$(echo $line | awk -F'"' '{print $2}')"
        echo "${this_name} ${fed_hash}"
      fi
    done
  elif [ "${TEXT_FILE}" != "" ] ; then
    for line in $(cat "${TEXT_FILE}")
    do
      fed_nvr="$(echo ${line} | sed "s/-[0-9]*:/-/" | sed 's/.src$//')"
      fed_hash="$(fedpkg gitbuildhash ${fed_nvr} 2>/dev/null)"
      if [ "${fed_hash}" == "" ] ; then
        fed_hash="$(fedpkg gitbuildhash ${fed_nvr} 2>&1 | awk -F'?#' '{print $2}')"
      fi
      this_name="$(koji rpminfo ${fed_nvr}.src | grep 'SRPM Path:' | awk -F'/' '{print $5}')"
      echo "${this_name} ${fed_hash} ${fed_nvr}"
    done
  elif [ "${PACKAGE_LIST}" != "" ] ; then
    for this_name in ${PACKAGE_LIST}
    do
      cd ${WORKDIR}/tmp
      fedpkg clone ${this_name} >> ${LOGFILE} 2>&1
      cd ${this_name}
      git checkout ${FED_GIT_CHECKOUT} >> ${LOGFILE} 2>&1
      fed_hash="$(git log -n1 --format=%H)"
      cd ${WORKDIR}/tmp
      rm -rf ${WORKDIR}/tmp/${this_name}
      echo "${this_name} ${fed_hash}"
    done
  else
    echo ; echo "ERROR: No packages or files given to process" ; echo
    usage
    exit 5
  fi
}

###############
# Update overall status in results directory
###############
update_overall_status() {
  update_name="${1}"
  update_nvr="${2}"
  update_status="${3}"
  update_task_number="${4}"
  update_fed_nvr="${5}"
  update_fed_status="${6}"
  SCRIPT_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  if [ -f ${SCRIPT_HOME}/fed-to-brew.conf ] ; then
    source ${SCRIPT_HOME}/fed-to-brew.conf
  elif [ -f /etc/fed-to-brew.conf ] ; then
    source /etc/fed-to-brew.conf
  else
    echo "Unable to find fed-to-brew.conf"
    echo "Expecting it to be ${SCRIPT_HOME}/fed-to-brew.conf or /etc/fed-to-brew.conf"
    echo "Exiting ..."
    exit 42
  fi

  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    update_name: ${update_name}"
    echo "    update_nvr: ${update_nvr}"
    echo "    update_status: ${update_status}"
    echo "    update_task_number: ${update_task_number}"
    echo "    update_fed_nvr: ${update_fed_nvr}"
    echo "    update_fed_status: ${update_fed_status}"
  fi
  flock ${LOCK_FILE} echo "${update_name} ${update_nvr} ${update_status} ${update_task_number} ${update_fed_nvr} ${update_fed_status}" >> ${OVERALL_TXT}
}

###############
# rsync directory out to remote server
###############
rsync_out() {
  this_dir="${1}"
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    this_dir: ${this_dir}"
    echo "    SYNC_REMOTE: ${SYNC_REMOTE}"
  fi
  if [ "${this_dir}" != "" ] && [ -d ${WORKDIR}/${this_dir} ] ; then
    rsync -avH --exclude=.git/ --delete ${WORKDIR}/${this_dir}/ ${SYNC_REMOTE}/${this_dir}/
  else
    echo "  ERROR: We cannot rsync ${WORKDIR}/${this_dir} remotely"
  fi
}

###############
# rsync directory in from remote server
###############
rsync_in() {
  this_dir="${1}"
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    this_dir: ${this_dir}"
    echo "    SYNC_REMOTE: ${SYNC_REMOTE}"
  fi
  if [ "${this_dir}" != "" ] ; then
    rsync -avH --exclude=.git/ --delete ${SYNC_REMOTE}/${this_dir}/ ${WORKDIR}/${this_dir}/
  else
    echo "  ERROR: No directory was passed to rsync into"
  fi
}

###############
# Sync fedora dist-git to brew dist-git
###############
sync_distgit() {
  job_type="${1}"
  job_number="${2}"
  this_name="$(echo ${3} | awk '{print $1}')"
  fed_hash="$(echo ${3} | awk '{print $2}')"
  if [ "${fed_hash}" == "" ] ; then
    fed_hash="${FED_GIT_CHECKOUT}"
  fi
  echo "    [${this_name}] Syncing dist-git start"

  # Checkout Brew dist-git
  echo "      [${this_name}] Download and Setup Brew dist-git repo"
  cd ${WORKDIR}/brew
  if [ -d ${this_name} ] ; then
    rm -rf ${this_name}
  fi
  rhpkg clone ${this_name} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to clone ${this_name}"
    echo "        [${this_name}] You might not have permissions, or might not be a package."
    end_job ${job_number}
    exit 1
  fi
  cd ${this_name}
  rhpkg switch-branch ${BREW_BRANCH} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
    echo "        [${this_name}] Not proceeding further with ${this_name} sync."
    end_job ${job_number}
    exit 1
  fi

  echo "      [${this_name}] Setup Fedora dist-git repo as remote"
  # rhpkg remote add fedora
  git remote add fedora https://src.fedoraproject.org/rpms/${this_name}.git
  git fetch fedora >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to Setup Fedora dist-git repo as remote"
    echo "        [${this_name}] Not proceeding further with ${this_name} sync."
    end_job ${job_number}
    exit 1
  fi

  # rsync fed to brew
  echo "      [${this_name}] Merging from Fed dist-git to Brew dist-git"
  if [ "${CUSTOM_MESSAGE}" == "" ] ; then
    COMMIT_MESSAGE="Merge Fedora commit into rhel-8.0"
  else
    COMMIT_MESSAGE="${CUSTOM_MESSAGE}"
  fi
  git merge -X theirs --allow-unrelated-histories -m "${COMMIT_MESSAGE} - fed_hash: ${fed_hash}" ${fed_hash} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to merge Fedora dist-git repo into Brew dist-git repo"
    echo "        [${this_name}] Not proceeding further with ${this_name} sync."
    end_job ${job_number}
    exit 1
  fi
  # Get Fedoras sources
  fedpkg sources >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    # For hashtags we have to pass a dist, assuming rawhide
    fedpkg --dist ${FED_DIST} sources >> ${LOGFILE} 2>&1
    if ! [ $? -eq 0 ] ; then
      echo "      [${this_name}] Error: We are unable to get our sources for ${this_name}"
      end_job ${job_number}
      exit 1
    fi
  fi

  # Push up to brew dist-git
  echo "      [${this_name}] Uploading sources to Brew dist-git"
  cd ${WORKDIR}/brew/${this_name}
  if grep -q SHA512 sources ; then
    source_list="$(cat sources | awk -F"(" '{print $2}' | awk -F")" '{print $1}' ORS=' ')"
  elif grep -q ^MD5 sources ; then
    source_list="$(cat sources | awk -F"(" '{print $2}' | awk -F")" '{print $1}' ORS=' ')"
  else
    source_list="$(cat sources | awk '{print $2}' ORS=' ')"
  fi
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    [${this_name}] source_list: ${source_list}"
    echo "    [${this_name}] COMMIT_MESSAGE: ${COMMIT_MESSAGE}"
  fi
  rhpkg new-sources ${source_list} >> ${LOGFILE} 2>&1
  git add -A >> ${LOGFILE} 2>&1
  rhpkg commit -m "Uploaded sources to go with sync from Fedora - fed_hash: ${fed_hash}" >> ${LOGFILE} 2>&1

  echo "      [${this_name}] Pushing everything to Brew dist-git"
  rhpkg push >> ${LOGFILE} 2>&1
  BREW_COMMIT_HASH="$(git log -n1 --format=%H)"
  THIS_NVR="$(fedpkg --release master verrel 2>/dev/null | sed 's|.fc2[0-9]|.dist|')"
  if [ "${THIS_NVR}" == "" ] ; then
    THIS_NVR="${this_name}"
  fi

  # Document what hashes matchs
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    [${this_name}] THIS_NVR: ${THIS_NVR}"
    echo "    [${this_name}] fed_hash: ${fed_hash}"
    echo "    [${this_name}] BREW_COMMIT_HASH: ${BREW_COMMIT_HASH}"
  fi
  echo "${THIS_NVR} fed_rev: ${fed_hash} brew_rev: ${BREW_COMMIT_HASH}" >> ${WORKDIR}/map/${this_name}

  echo "    [${this_name}] Syncing End"
  if [ "${job_type}" == "newjob" ] ; then
    end_job ${job_number}
  fi
}

###############
# Build packages
###############
build_package() {
  job_number="${1}"
  this_name="$(echo ${2} | awk '{print $1}')"
  fed_hash="$(echo ${2} | awk '{print $2}')"
  this_nvr="$(echo ${2} | awk '{print $3}')"
  if [ "${fed_hash}" == "" ] ; then
    fed_hash="${FED_GIT_CHECKOUT}"
  fi
  this_brew_check=""
  if [ "${BREW_CHECK}" == "TRUE" ] ; then
    wget -q -O /dev/null ${BREW_DISTGIT_URL}/rpms/${this_name}/log/?h=${BREW_BRANCH}
    if [ $? -gt 0 ] ; then
      this_brew_check="FAILED"
    fi
  fi
  if [ "${this_brew_check}" == "FAILED" ] ; then
    echo "  [${this_name}] BREW DIST-GIT IS NOT SETUP YET"
    echo "${this_name}" >> ${WORKDIR}/logs/request-needed-$(date +%Y-%m-%d)
  else
    echo "  [${this_name}] Build Setup Start"
    if [ -f ${WORKDIR}/map/${this_name} ] ; then
      test_hash="$(tail -n 1 ${WORKDIR}/map/${this_name} | awk '{print $3}')"
    fi
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    NVR: ${this_nvr}"
      echo "    Name: ${this_name}"
      echo "    Fed Hash: ${fed_hash}"
      echo "    Old Hash: ${test_hash}"
    fi
    if [ "${test_hash}" == "${fed_hash}" ] ; then
      echo "    [${this_name}] Already synced from Fedora to Brew dist-git"
    else
      echo "    [${this_name}] Syncing from Fedora to Brew dist-git"
      sync_distgit "oldjob" ${job_number} "${this_name} ${fed_hash}"
    fi
    # Everything should be setup by now, lets start the build
    if [ -f ${WORKDIR}/logs/${this_name}.build ] ; then
      echo "    [${this_name}] Already Building"
    else

      if grep "fednvr:${this_nvr} fedhash:${fed_hash}" ${WORKDIR}/results/${this_name}/status.txt 2>/dev/null | grep -q SUCCESS:  ; then
        echo "    [${this_name}] Already Successfully Built"
      else
        echo "    [${this_name}] Build Needed - Setting up"
        if [ -d ${WORKDIR}/brew/${this_name} ] ; then
          cd ${WORKDIR}/brew/${this_name}
          rhpkg switch-branch ${BREW_BRANCH} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
            echo "      [${this_name}] Not proceeding further with ${this_name} build."
            end_job ${job_number}
            exit 2
          fi
          rhpkg pull >/dev/null 2>&1
        else
          cd ${WORKDIR}/brew
          rhpkg clone ${this_name} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to clone ${this_name}"
            echo "      [${this_name}] You might not have permissions, or"
            echo "      [${this_name}] ${this_name} might not be a package."
            end_job ${job_number}
            exit 2
          fi
          cd ${WORKDIR}/brew/${this_name}
          rhpkg switch-branch ${BREW_BRANCH} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
            echo "      [${this_name}] Not proceeding further with ${this_name} build."
            end_job ${job_number}
            exit 2
          fi
        fi
        echo "${this_name} fednvr:${this_nvr} fedhash:${fed_hash} " >> ${WORKDIR}/logs/${this_name}.build
        if [ "${USE_DIFFERENT_TARGETS}" == "true" ] || [ "${USE_DIFFERENT_TARGETS}" == "TRUE" ] ; then
          targeted_packages=${!dict_pkg_target[@]}
          if [[ "${targeted_packages}" =~ (^|[[:space:]])"${this_name}"($|[[:space:]]) ]] ; then
            KOJI_TARGET=${dict_pkg_target[${this_name}]}
          fi
          echo "      [${this_name}] KOJI_TARGET:${KOJI_TARGET}"
        fi
        rhpkg build --skip-nvr-check --nowait --target ${KOJI_TARGET} >> ${WORKDIR}/logs/${this_name}.build 2>&1
      fi
    fi
    echo "  [${this_name}] Build Setup End"
  fi
  end_job ${job_number}
}

###############
# Module Status
###############
check_module_status() {
  mkdir -p ${WORKDIR}/{results,tmp}/modules
  # Check those currently being worked on
  echo "    Generating list of modules ..."
  wget -q -O ${WORKDIR}/tmp/modules/pungi-modlist.raw 'https://code.engineering.redhat.com/gerrit/gitweb?p=pungi-redhat.git;a=blob_plain;f=variants-appstream.xml;hb=refs/heads/rhel-8.0'
  grep '<module>' ${WORKDIR}/tmp/modules/pungi-modlist.raw |  cut -d'>' -f2 | cut -d'<' -f1 >> ${WORKDIR}/tmp/modules/pungi-modlist.txt
  rm -f ${WORKDIR}/tmp/modules/pungi-modlist.raw
  cp -p ${MODULES_DIR}/upcoming-modules.txt ${WORKDIR}/tmp/modules/upcoming-modules.txt
  cat ${WORKDIR}/tmp/modules/pungi-modlist.txt ${WORKDIR}/tmp/modules/upcoming-modules.txt | sort -u -o ${WORKDIR}/tmp/modules/all-modules.txt
  echo "    Checking modules still building ..."
  mbs-build -s https://mbs.engineering.redhat.com/ -p rhpkg overview 2>&1 | while read line
  do
    this_task_id="$(echo $line |awk '{print $1}')"
    if [ "${this_task_id}" != "ID" ] && [ "${this_task_id}" != "----" ] ; then
      this_module_name="$(echo $line | awk '{print $6}' | cut -d'-' -f1,2 | sed 's|-|:|' )"
      if grep -q "^${this_module_name}$" ${WORKDIR}/tmp/modules/all-modules.txt ; then
        if ! [ -d ${WORKDIR}/tmp/modules/${this_module_name} ] ; then
          this_status="$(echo $line |awk '{print $2}')"
          mkdir -p ${WORKDIR}/tmp/modules/${this_module_name}
          echo "${line}" >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          echo "-------" >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          mbs-build -q -s https://mbs.engineering.redhat.com/ -p rhpkg info ${this_task_id} 2>/dev/null | sed "s|https://koji.fedoraproject.org/koji|https://brewweb.engineering.redhat.com/brew|g"  >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          this_total="$(grep -e BUILDING -e FAILED -e COMPLETE ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_complete="$(grep -e COMPLETE ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_failed="$(grep -e FAILED ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_building="$(grep -e BUILDING ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          echo "${this_module_name} ${this_status} ${this_task_id} ${this_building}/${this_failed}/${this_complete}/${this_total}" >> ${WORKDIR}/tmp/modules/module-status.txt
        fi
      fi
    fi
  done

  # Check older module builds
  echo "    Checking modules already built ..."
  mbs-build -s https://mbs.engineering.redhat.com/ -p rhpkg overview --finished --limit 0 2>&1 | while read line
  do
    this_task_id="$(echo $line |awk '{print $1}')"
    if [ "${this_task_id}" != "ID" ] && [ "${this_task_id}" != "----" ] ; then
      this_module_name="$(echo $line | awk '{print $6}' | cut -d'-' -f1,2 | sed 's|-|:|' )"
      if grep -q "^${this_module_name}$" ${WORKDIR}/tmp/modules/all-modules.txt ; then
        if ! [ -d ${WORKDIR}/tmp/modules/${this_module_name} ] ; then
          this_status="$(echo $line |awk '{print $2}')"
          mkdir -p ${WORKDIR}/tmp/modules/${this_module_name}
          echo "${line}" >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          echo "-------" >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          mbs-build -q -s https://mbs.engineering.redhat.com/ -p rhpkg info ${this_task_id} 2>/dev/null | sed "s|https://koji.fedoraproject.org/koji|https://brewweb.engineering.redhat.com/brew|g"  >> ${WORKDIR}/tmp/modules/${this_module_name}/status.txt
          this_total="$(grep -e BUILDING -e FAILED -e COMPLETE ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_complete="$(grep -e COMPLETE ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_failed="$(grep -e FAILED ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          this_building="$(grep -e BUILDING ${WORKDIR}/tmp/modules/${this_module_name}/status.txt | wc -l)"
          echo "${this_module_name} ${this_status} ${this_task_id} ${this_building}/${this_failed}/${this_complete}/${this_total}" >> ${WORKDIR}/tmp/modules/module-status.txt
        fi
      fi
    fi
  done

  # Create Package List
  echo "    Creating Package List from Modules ..."
  cp -rp ${MODULES_DIR}/task_cache.txt ${WORKDIR}/tmp/modules/
  TEMP_PKG_LIST="${WORKDIR}/tmp/modules/modules.package-list.txt"
  touch ${TEMP_PKG_LIST}
  ls -1 ${WORKDIR}/tmp/modules/ | while read this_mod_name
  do
    if [ -s ${WORKDIR}/tmp/modules/${this_mod_name}/status.txt ] ; then
      grep https ${WORKDIR}/tmp/modules/${this_mod_name}/status.txt | grep -v module-build-macros | cut -d'=' -f2 | while read this_task_num
      do
        this_pkg_name="$(grep "^${this_task_num} " ${WORKDIR}/tmp/modules/task_cache.txt | awk '{print $2}')"
        if [ "${this_pkg_name}" == "" ] ; then
          this_pkg_name="$(brew taskinfo -v ${this_task_num} | grep Source: | cut -d'/' -f5 | cut -d'?' -f1)"
          echo "${this_task_num} ${this_pkg_name}" >> ${WORKDIR}/tmp/modules/task_cache.txt
        fi
        # echo "      ${this_pkg_name} ${this_mod_name}"
        echo "${this_pkg_name} ${this_mod_name}" >> ${WORKDIR}/tmp/modules/pkg-list-${this_mod_name}
      done
      sort -u -o ${WORKDIR}/tmp/modules/pkg-list-${this_mod_name} ${WORKDIR}/tmp/modules/pkg-list-${this_mod_name}
      join -a 1 -a 2 --nocheck-order ${TEMP_PKG_LIST} ${WORKDIR}/tmp/modules/pkg-list-${this_mod_name} >> ${TEMP_PKG_LIST}.tmp 2>/dev/null
      sort -o ${TEMP_PKG_LIST} ${TEMP_PKG_LIST}.tmp
      rm -f ${TEMP_PKG_LIST}.tmp
      rm -f ${WORKDIR}/tmp/modules/pkg-list-${this_mod_name}
    fi
  done

  # Finish and cleanup
  sort -u -o ${WORKDIR}/tmp/modules/module-status.txt ${WORKDIR}/tmp/modules/module-status.txt
  rsync -a --delete ${WORKDIR}/tmp/modules/ ${MODULES_DIR}/
  rm -rf ${WORKDIR}/tmp/modules/*

}
###############
# Update Bootstrap Info
###############
update_bootstrap_info() {
  echo "    Starting Package Lists Updating"

  # Find leaves
  echo "      Finding Leaves"
  cd ${WEB_DIR}
  rm -f ${WORKDIR}/tmp/leaves.txt
  ls -1 | grep -v -e ^dependencies$ -e ^modules$ -e ^archive$ -e .txt$ -e .html$ | while read line
  do
    if ! [ -s $line/whatrequires/overall.sname.txt ] ; then
      echo $line >> ${WORKDIR}/tmp/leaves.txt
    fi
  done
  sort -u -o ${WORKDIR}/tmp/leaves.txt ${WORKDIR}/tmp/leaves.txt
  if diff -q ${WORKDIR}/tmp/leaves.txt ${WEB_DIR}/Leaves.txt > /dev/null ; then
    # No change in Leaves, remove the temp file
    rm -f ${WORKDIR}/tmp/leaves.txt
  else
    # Leaves changed, move new one in
    mv -v ${WORKDIR}/tmp/leaves.txt ${WEB_DIR}/Leaves.txt
  fi

  # Find BaseOS Packages
  echo "      Finding BaseOS Packages"
  rm -f ${WORKDIR}/tmp/BaseOS.{html,nvr,txt}
  wget -q -O ${WORKDIR}/tmp/BaseOS.html http://download-node-02.eng.bos.redhat.com/nightly/latest-RHEL-8/compose/BaseOS/source/tree/Packages/
  grep 'src.rpm' ${WORKDIR}/tmp/BaseOS.html | cut -d'"' -f6 | sed 's/.src.rpm$/.src/' | sort -u -o ${WORKDIR}/tmp/BaseOS.nvr
  for check_package in $(cat ${WORKDIR}/tmp/BaseOS.nvr)
  do
    grep "^${check_package} " ${DEB_DIR}/conversion-bnvra-bname-sname.txt | awk '{print $3}' >> ${WORKDIR}/tmp/BaseOS.txt
  done
  sort -u -o ${WORKDIR}/tmp/BaseOS.txt ${WORKDIR}/tmp/BaseOS.txt
  if diff -q ${WORKDIR}/tmp/BaseOS.txt ${WEB_DIR}/BaseOS.txt > /dev/null ; then
    # No change in Leaves, remove the temp file
    rm -f ${WORKDIR}/tmp/BaseOS.txt
  else
    # Leaves changed, move new one in
    mv -v ${WORKDIR}/tmp/BaseOS.txt ${WEB_DIR}/BaseOS.txt
  fi

  # Find AppStream Packages
  echo "      Finding AppStream Packages"
  rm -f ${WORKDIR}/tmp/AppStream.{html,nvr,txt}
  wget -q -O ${WORKDIR}/tmp/AppStream.html http://download-node-02.eng.bos.redhat.com/nightly/latest-AppStream-8/compose/AppStream/source/tree/Packages/
  grep 'src.rpm' ${WORKDIR}/tmp/AppStream.html | cut -d'"' -f6 | sed 's/.src.rpm$/.src/' | sort -u -o ${WORKDIR}/tmp/AppStream.nvr
  for check_package in $(cat ${WORKDIR}/tmp/AppStream.nvr)
  do
    grep "^${check_package} " ${DEB_DIR}/conversion-bnvra-bname-sname.txt | awk '{print $3}' >> ${WORKDIR}/tmp/AppStream.txt
  done
  sort -u -o ${WORKDIR}/tmp/AppStream.txt ${WORKDIR}/tmp/AppStream.txt
  if diff -q ${WORKDIR}/tmp/AppStream.txt ${WEB_DIR}/AppStream.txt > /dev/null ; then
    # No change in Leaves, remove the temp file
    rm -f ${WORKDIR}/tmp/AppStream.txt
  else
    # Leaves changed, move new one in
    mv -v ${WORKDIR}/tmp/AppStream.txt ${WEB_DIR}/AppStream.txt
  fi

  # Get the list of packages in modules
  echo "      Finding Module Packages"
  cat ${MODULES_DIR}/modules.package-list.txt | awk '{print $1}' | sort -u -o ${WEB_DIR}/ModulePackagesBinary.txt
  rm -f ${WEB_DIR}/ModulePackages.txt
  cat ModulePackagesBinary.txt | while read line
  do
    grep " $line " ${WEB_DIR}/dependencies/conversion-bnvra-bname-sname.txt | head -n 1 | awk '{print $3}' >> ${WEB_DIR}/ModulePackages.txt
  done
  sort -u -o ${WEB_DIR}/ModulePackages.txt ${WEB_DIR}/ModulePackages.txt

  # Determine Unkown Leaves
  echo "      Finding Unkown Leaves"
  cat  ${WEB_DIR}/ModulePackages.txt ${WEB_DIR}/BaseOS.txt ${WEB_DIR}/AppStream.txt ${WEB_DIR}/KnownExtraLeaves.txt  ${WEB_DIR}/RedList.txt | sort -u -o ${WEB_DIR}/KnownLeaves.txt
  # cat  ${WEB_DIR}/TopLevel.txt  ${WEB_DIR}/ModulePackages.txt ${WEB_DIR}/BaseOS.txt ${WEB_DIR}/AppStream.txt ${WEB_DIR}/KnownExtraLeaves.txt  ${WEB_DIR}/RedList.txt | sort -u -o ${WEB_DIR}/KnownLeaves.txt
  comm -23 ${WEB_DIR}/TopLevel.txt ${WEB_DIR}/KnownLeaves.txt | sort -u -o ${WEB_DIR}/OrphanedTopLevel.txt
  comm -23 ${WEB_DIR}/Leaves.txt ${WEB_DIR}/KnownLeaves.txt | sort -u -o ${WEB_DIR}/UnknownLeaves.txt

  echo "    Ending Package Lists Updating"
}

###############
# Double Check Package status
###############
double_check_build_status() {
  #job_number="${1}"
  this_name="${1}"
  SCRIPT_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  if [ -f ${SCRIPT_HOME}/fed-to-brew.conf ] ; then
    source ${SCRIPT_HOME}/fed-to-brew.conf
  elif [ -f /etc/fed-to-brew.conf ] ; then
    source /etc/fed-to-brew.conf
  else
    echo "Unable to find fed-to-brew.conf"
    echo "Expecting it to be ${SCRIPT_HOME}/fed-to-brew.conf or /etc/fed-to-brew.conf"
    echo "Exiting ..."
    exit 42
  fi

  echo "  [${this_name}] Double Check Start"
  mkdir -p ${WEB_DIR}/${this_name}

  # Check if it's on the Red List
  wget -q -O /dev/null ${BREW_DISTGIT_URL}/rpms/${this_name}/tree/.do-not-sync-with-fedora?h=${BREW_BRANCH}
  if [ $? -eq 0 ] ; then
      echo "${this_name}" >> ${WEB_DIR}/RedList.txt
  fi

  brew list-tagged --latest  --rpms rhel-8.0-candidate ${this_name} | grep -v -e debuginfo -e debugsource  | sort -u -o ${WORKDIR}/tmp/${this_name}-test-nvra.txt
  if ! [ -s ${WORKDIR}/tmp/${this_name}-test-nvra.txt ] ; then
    brew list-tagged --latest  --rpms rhel-8.0-llvm-toolset-candidate ${this_name} | grep -v -e debuginfo -e debugsource  | sort -u -o ${WORKDIR}/tmp/${this_name}-test-nvra.txt
  fi
  if ! [ -s ${WORKDIR}/tmp/${this_name}-test-nvra.txt ] ; then
    brew list-tagged --latest  --rpms rhel-8.0-rust-toolset-candidate ${this_name} | grep -v -e debuginfo -e debugsource  | sort -u -o ${WORKDIR}/tmp/${this_name}-test-nvra.txt
  fi
  if ! [ -s ${WORKDIR}/tmp/${this_name}-test-nvra.txt ] ; then
    brew list-tagged --latest  --rpms rhel-8.0-go-toolset-candidate ${this_name} | grep -v -e debuginfo -e debugsource  | sort -u -o ${WORKDIR}/tmp/${this_name}-test-nvra.txt
  fi
  if [ -s ${WORKDIR}/tmp/${this_name}-test-nvra.txt ] ; then
    if diff -q ${WEB_DIR}/${this_name}/latest-nvra.txt ${WORKDIR}/tmp/${this_name}-test-nvra.txt > /dev/null ; then
      # There was no changes, no need to do anything.
      rm -f ${WORKDIR}/tmp/${this_name}-test-nvra.txt
      this_nvr="$(grep .src$ ${WEB_DIR}/${this_name}/latest-nvra.txt | sed 's/.src$//')"
      echo "    [${this_name}] Successful Build: ${this_nvr}"
      this_status="SUCCESS"
      task_number="$(brew buildinfo ${this_nvr}| grep ^Task: | awk '{print $2}')"
    else
      mv -f ${WORKDIR}/tmp/${this_name}-test-nvra.txt ${WEB_DIR}/${this_name}/latest-nvra.txt
      this_nvr="$(grep .src$ ${WEB_DIR}/${this_name}/latest-nvra.txt | sed 's/.src$//')"
      echo "    [${this_name}] Successful Build: ${this_nvr}"
      this_status="SUCCESS"
      task_number="$(brew buildinfo ${this_nvr}| grep ^Task: | awk '{print $2}')"
      # Find the binary packages
      this_vr="$(echo ${this_nvr} | sed "s/^${this_name}-//")"
      grep -v .src$ ${WEB_DIR}/${this_name}/latest-nvra.txt | sed "s/-${this_vr}.*//" | sort -u -o ${WEB_DIR}/${this_name}/binary-packages.txt
    fi
  else
    echo "    [${this_name}] No Builds"
    this_nvr="NONE"
    this_status="NONE"
    task_number="NONE"
    rm -f ${WEB_DIR}/${this_name}/test-nvra.txt
  fi
  # Check if mass rebuild was successful
  if [ "${this_nvr}" == "NONE" ] ; then
    this_brew_status="WARN"
    cd ${WORKDIR}/brew/
    if  ! [ -d ${this_name} ] ; then
      rhpkg clone ${this_name} >> ${LOGFILE} 2>&1
    fi
    cd ${this_name}
    rhpkg switch-branch rhel-8.0 >> ${LOGFILE} 2>&1
    rhpkg pull >> ${LOGFILE} 2>&1
    this_brew_nvr="$(rhpkg verrel 2>/dev/null | sed "s/.el8/${BREW_DIST}/")"
    if [ "${this_brew_nvr}" == "" ] ; then
      this_brew_nvr="NONE"
    fi
  else
    this_nvr_dist="$(echo ${this_nvr} | sed 's/.el8+[0-9]/.checkdist/' | sed 's/.el8_[0-9]/.checkdist/' | sed 's/.el8/.checkdist/')"
    this_check_nvr="$(echo ${this_nvr_dist} | sed "s/.checkdist/${BREW_DIST}/")"
    if [ "${this_nvr}" == "${this_check_nvr}" ] ; then
      this_brew_nvr="${this_nvr}"
      this_brew_status="SUCCESS"
    else
      this_brew_status="WARN"
      cd ${WORKDIR}/brew/
      if  ! [ -d ${this_name} ] ; then
        rhpkg clone ${this_name} >> ${LOGFILE} 2>&1
      fi
      cd ${this_name}
      rhpkg switch-branch rhel-8.0 >> ${LOGFILE} 2>&1
      rhpkg pull >> ${LOGFILE} 2>&1
      this_brew_nvr="$(rhpkg verrel 2>/dev/null | sed "s/.el8/${BREW_DIST}/")"
    fi
  fi
  cd ${SCRIPT_HOME}
  update_overall_status ${this_name} ${this_nvr} ${this_status} ${task_number} ${this_brew_nvr} ${this_brew_status}
  echo "  [${this_name}] Double Check End"
  #end_job ${job_number}
}

###############
# Check build status
###############
check_build_status() {
  job_number="${1}"
  build_log="${2}"
  this_stat_line="$(head -n1 ${build_log})"
  this_name="$(echo ${build_log} | sed 's|.build$||')"
  task_number="$(grep Created ${build_log} | awk '{print $3}')"
  echo "  [${this_name}] Check Start"
  if [ "${task_number}" == "" ] ; then
    echo "    [${this_name}] ERROR: No task_number found"
    this_nvr="ERROR"
    task_number="ERROR"
    this_status="ERROR"
    this_fed_nvr="NONE"
    this_fed_status="NONE"
    # update_overall_status ${this_name} ${this_nvr} ${this_status} ${task_number} ${this_fed_nvr} ${this_fed_status}
  else
    this_taskinfo="$(brew taskinfo ${task_number})"
    this_state="$(echo "${this_taskinfo}" | grep State: | awk '{print $2}')"
    this_nvr="$(echo "${this_taskinfo}" | grep Build: | awk '{print $2}')"
    this_nvr_dist="$(echo ${this_nvr} | sed 's/.el8+[0-9]/.dist/' | sed 's/.el8_[0-9]/.dist/' | sed 's/.el8/.dist/')"
    this_fed_nvr="$(grep ^${this_nvr_dist} ${WEB_DIR}/BootSelf-Full-Dist.txt)"
    if [ "${this_fed_nvr}" == "" ] ; then
      this_fed_name="$(grep ^${this_name} ${WEB_DIR}/BootSelf.txt | head -n1)"
      if [ "${this_fed_name}" == "" ] ; then
        this_fed_nvr="NONE"
        this_fed_status="NONE"
      else
        this_fed_nvr="$(grep ^${this_fed_name} ${WEB_DIR}/BootSelf-Full.txt | head -n1)"
        this_fed_status="WARN"
      fi
    else
      this_fed_status="SUCCESS"
    fi
    echo "    [${this_name}] Current State: ${this_state}"
    if [ "${this_state}" == "closed" ] || [ "${this_state}" == "failed" ] || [ "${this_state}" == "canceled" ] ; then
      mkdir -vp ${WORKDIR}/results/${this_name}/${task_number} > /dev/null
      if [ "${this_state}" == "closed" ] ; then
        this_status="SUCCESS"
      fi
      if [ "${this_state}" == "failed" ] ; then
        this_status="FAILURE"
        if [ "${DOWNLOAD_LOGS}" == "true" ] || [ "${DOWNLOAD_LOGS}" == "TRUE" ] ; then
          echo "      [${this_name}] Downloading failed build logs."
          brew download-logs -r -d ${WORKDIR}/results/${this_name}/${task_number} ${task_number} > /dev/null 2>&1
        fi
      fi
      if [ "${this_state}" == "canceled" ] ; then
        this_status="FAILURE"
      fi
      # update_overall_status ${this_name} ${this_nvr} ${this_status} ${task_number} ${this_fed_nvr} ${this_fed_status}
      this_fed_info="$(echo ${this_stat_line} | awk '{print $2 " " $3}')"
      echo "${this_status}: ${this_nvr} ${BREW_WEB_URL}/taskinfo?taskID=${task_number} ${this_fed_info}" >> ${WORKDIR}/results/${this_name}/status.txt
      mv ${WORKDIR}/logs/${build_log} ${WORKDIR}/results/${this_name}/${task_number}/${build_log}.txt
      # rm -rf ${WORKDIR}/brew/${this_name}
    else
      this_status="BUILDING"
      # update_overall_status ${this_name} ${this_nvr} ${this_status} ${task_number} ${this_fed_nvr} ${this_fed_status}
    fi
  fi
  echo "  [${this_name}] Check End"
  end_job ${job_number}
}

###############
# Create Modules Status Web Page
###############
create_modules_status_page() {
  sort -o ${MODULES_TXT} ${MODULES_TXT}
  overall_total="$(cat ${MODULES_TXT} |wc -l)"
  overall_building="$(grep ' build ' ${MODULES_TXT} |wc -l)"
  overall_success="$(grep ' ready ' ${MODULES_TXT} |wc -l)"
  overall_failure="$(grep ' failed ' ${MODULES_TXT} |wc -l)"

  echo "    Starting Modules Overall web page"
  this_html="${MODULES_HTML}"
  rm -f ${this_html}
  echo "<html>" >> ${this_html}
  echo "<head><title>Module Build Progress ${this_type}</title></head>" >> ${this_html}
  echo "<body>" >> ${this_html}
  echo "<h1>Module Build Progress: ${BREW_DIST}</h1>" >> ${this_html}
  echo "<p>Page updated: " >> ${this_html}
  date --utc >> ${this_html}
  echo "</p>" >> ${this_html}
  echo "<h2>General Pages</h2>" >> ${this_html}
  echo "<p>" >> ${this_html}
  echo "<a href=\"../overall-status.html\">Non-Module Overall Builds </a>" >> ${this_html}
  echo "<br><a href=\"modules.package-list.txt\">List of Packages in Modules </a> .. " >> ${this_html}
  echo "<a href=\"module.blacklist.txt\">Module BlackList </a>" >> ${this_html}
  echo "</p>" >> ${this_html}
  echo "<h2>Totals</h2>" >> ${this_html}
  echo "<p>" >> ${this_html}
  echo "Building: <strong>${overall_building}</strong><br>" >> ${this_html}
  echo "Success: <strong>${overall_success}</strong><br>" >> ${this_html}
  echo "Failure: <strong>${overall_failure}</strong><br>" >> ${this_html}
  echo "Total: <strong>${overall_total}</strong><br>" >> ${this_html}
  echo "</p>" >> ${this_html}
  echo "<h2>Details</h2>" >> ${this_html}
  echo "<table border=1 style="width:100%">" >> ${this_html}
  echo "<tr><th>Name</th><th>STATUS</th><th>ID</th><th>Progress: B/F/C/T</th></tr>" >> ${this_html}

  cat ${MODULES_TXT} | while read line
  do
    this_name="$(echo ${line} | awk '{print $1}')"
    this_status="$(echo ${line} | awk '{print $2}')"
    this_id="$(echo ${line} | awk '{print $3}')"
    this_progress="$(echo ${line} | awk '{print $4}')"
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    this_name: ${this_name}"
      echo "    this_status: ${this_status}"
      echo "    this_id: ${this_id}"
      echo "    this_progress: ${this_progress}"
    fi
    this_color="#FF0000"
    if [ "${this_status}" == "ready" ] ; then
      this_color="#00FF00"
      this_view_status="SUCCESS"
    elif [ "${this_status}" == "build" ] ; then
      this_color="#00FFFF"
      this_view_status="BUILDING"
    else
      this_view_status="FAILURE"
    fi
    echo "<tr><td><a href=\"${this_name}/status.txt\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_view_status}</td><td>${this_id}</td><td>${this_progress}</td></tr>" >> ${this_html}
  done

  echo "</table>" >> ${this_html}
  echo "</body>" >> ${this_html}
  echo "</html>" >> ${this_html}
}

###############
# Create Status Web Page
###############
create_status_page() {
  sort -o ${OVERALL_TXT} ${OVERALL_TXT}
  overall_total="$(cat ${OVERALL_TXT} |wc -l)"
  overall_success="$(grep SUCCESS ${OVERALL_TXT} |wc -l)"
  overall_warn="$(grep WARN ${OVERALL_TXT} | grep -v -e FAILURE -e ERROR -e NONE |wc -l)"
  overall_none="$(grep -e FAILURE -e ERROR -e NONE ${OVERALL_TXT} |wc -l)"

  echo "    Starting Overall web page"
  for this_type in Overall Warn None
  do
    if [ "${this_type}" == "Overall" ] ; then
      this_html="${OVERALL_HTML}"
    elif [ "${this_type}" == "Warn" ] ; then
      this_html="${BUILDING_HTML}"
    else
      this_html="${FAILURE_HTML}"
    fi

    rm -f ${this_html}
    echo "<html>" >> ${this_html}
    echo "<head><title>RHEL Build Progress ${this_type}</title></head>" >> ${this_html}
    echo "<body>" >> ${this_html}
    echo "<h1>RHEL ${this_type} Build Progress: ${BREW_DIST}</h1>" >> ${this_html}
    cat ${WEB_DIR}/${this_type}.comment.txt >> ${this_html}
    echo "<p>Page updated: " >> ${this_html}
    date --utc >> ${this_html}
    echo "<br><a href=\"overall-status-$(date --date=yesterday +%Y-%m-%d).html\">Yesterdays Overall Status $(date --date=yesterday +%Y-%m-%d)</a>" >> ${this_html}
    echo "</p>" >> ${this_html}
    echo "<h2>Other Status Pages</h2>" >> ${this_html}
    echo "<p>" >> ${this_html}
    for this_mod_name in overall-status ${MODULE_LIST}
    do
      echo " .. <a href=\"${this_mod_name}.html\">${this_mod_name} </a> .. " >> ${this_html}
    done
    echo "<br><a href=\"${MODULES_HTML_LOCAL}\">Module Builds </a>" >> ${this_html}
    echo "</p>" >> ${this_html}
    echo "<h2>Totals</h2>" >> ${this_html}
    echo "<p>" >> ${this_html}
    echo "<a href=\"overall-status.html\">Success:</a> <strong>${overall_success}</strong><br>" >> ${this_html}
    echo "<a href=\"overall-building-status.html\">Warn:</a> <strong>${overall_warn}</strong><br>" >> ${this_html}
    echo "<a href=\"overall-failure-status.html\">NoBuilds:</a> <strong>${overall_none}</strong><br>" >> ${this_html}
    echo "Total: <strong>${overall_total}</strong><br>" >> ${this_html}
    echo "</p>" >> ${this_html}
    echo "<h2>Details</h2>" >> ${this_html}
    echo "<table border=1 style="width:100%">" >> ${this_html}
    echo "<tr><th>Name</th><th>Brew Built NVR</th><th>Brew dist-git NVR</th><th>Build URL</th></tr>" >> ${this_html}
  done

  cat ${OVERALL_TXT} | while read line
  do
    this_name="$(echo ${line} | awk '{print $1}')"
    this_nvr="$(echo ${line} | awk '{print $2}')"
    this_status="$(echo ${line} | awk '{print $3}')"
    this_task="$(echo ${line} | awk '{print $4}')"
    this_fed_nvr="$(echo ${line} | awk '{print $5}')"
    this_fed_status="$(echo ${line} | awk '{print $6}')"
    if [ "${this_task}" == "NONE" ] ; then
      task_url=" "
    else
      task_url="<a href=\"${BREW_WEB_URL}/taskinfo?taskID=${this_task}\">${this_task}</a>"
    fi
    task_number="$(echo ${task_url} | awk -F'=' '{print $2}')"
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    this_name: ${this_name}"
      echo "    this_nvr: ${this_nvr}"
      echo "    this_status: ${this_status}"
      echo "    task_number: ${task_number}"
      echo "    task_url: ${task_url}"
    fi
    this_color="#CCCCFF"
    if [ "${this_status}" == "SUCCESS" ] ; then
      this_color="#00FF00"
    fi
    this_fed_color="#FFFFFF"
    if [ "${this_fed_status}" == "SUCCESS" ] ; then
      this_fed_color="#00FF00"
    elif [ "${this_fed_status}" == "WARN" ] ; then
      this_fed_color="#FFFFCC"
    fi
    echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_nvr}</td><td bgcolor=\"${this_fed_color}\">${this_fed_nvr}</td><td>${task_url}</td></tr>" >> ${OVERALL_HTML}
    if [ "${this_status}" == "SUCCESS" ] && [ "${this_fed_status}" == "WARN" ] ; then
      echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_nvr}</td><td bgcolor=\"${this_fed_color}\">${this_fed_nvr}</td><td>${task_url}</td></tr>" >> ${BUILDING_HTML}
    elif [ "${this_status}" == "NONE" ] ; then
      echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_nvr}</td><td bgcolor=\"${this_fed_color}\">${this_fed_nvr}</td><td>${task_url}</td></tr>" >> ${FAILURE_HTML}
    fi
  done

  for mod_name in ${MODULE_LIST}
  do
    echo "    Starting ${mod_name} web page"
    rm -f ${WEB_DIR}/${mod_name}.html
    echo "<html>" >> ${WEB_DIR}/${mod_name}.html
    echo "<head><title>RHEL Build Progress ${mod_name}</title></head>" >> ${WEB_DIR}/${mod_name}.html
    echo "<body>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h1>RHEL ${mod_name} Build Progress: ${BREW_DIST}</h1>" >> ${WEB_DIR}/${mod_name}.html
    cat ${WEB_DIR}/${mod_name}.comment.txt >> ${WEB_DIR}/${mod_name}.html
    echo "<p>Page updated: " >> ${WEB_DIR}/${mod_name}.html
    date --utc >> ${WEB_DIR}/${mod_name}.html
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Other Status Pages</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<p>" >> ${WEB_DIR}/${mod_name}.html
    for this_mod_name in overall-status ${MODULE_LIST}
    do
      echo " .. <a href=\"${this_mod_name}.html\">${this_mod_name} </a> .. " >> ${WEB_DIR}/${mod_name}.html
    done
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Totals</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<p>" >> ${WEB_DIR}/${mod_name}.html
    echo "Success: <strong>::SUCC-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Warn: <strong>::BUILD-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "NoBuilds: <strong>::UNKNOWN-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Total: <strong>::TOTAL-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Details</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<table border=1 style="width:100%">" >> ${WEB_DIR}/${mod_name}.html
    echo "<tr><th>Name</th><th>Brew Built NVR</th><th>Brew dist-git NVR</th><th>Build URL</th></tr>" >> ${WEB_DIR}/${mod_name}.html

    cat  ${WEB_DIR}/${mod_name}.txt | while read line
    do
      if [ "${line}" != "" ] ; then
        package_line="$(grep ">${line}<" ${OVERALL_HTML})"
        if [ "${package_line}" == "" ]; then
          package_line="<tr><td>${line}</td><td>NO INFO</td><td>No Info</td><td>No Info</td></tr>"
        fi
        echo "${package_line}" >> ${WEB_DIR}/${mod_name}.html
      fi
    done

    echo "</table>" >> ${WEB_DIR}/${mod_name}.html
    echo "</body>" >> ${WEB_DIR}/${mod_name}.html
    echo "</html>" >> ${WEB_DIR}/${mod_name}.html

    mod_total="$(cat ${WEB_DIR}/${mod_name}.txt |wc -l)"
    mod_warn="$(grep '#FFFFCC' ${WEB_DIR}/${mod_name}.html | grep -v '#CCCCFF' |wc -l)"
    mod_success="$(grep '#00FF00' ${WEB_DIR}/${mod_name}.html |wc -l)"
    mod_unknown="$(grep '#CCCCFF' ${WEB_DIR}/${mod_name}.html |wc -l)"
    sed -i "s/::TOTAL-PLACEHOLDER::/${mod_total}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::BUILD-PLACEHOLDER::/${mod_warn}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::SUCC-PLACEHOLDER::/${mod_success}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::UNKNOWN-PLACEHOLDER::/${mod_unknown}/" ${WEB_DIR}/${mod_name}.html

  done

  for this_html in ${OVERALL_HTML} ${BUILDING_HTML} ${FAILURE_HTML}
  do
    echo "</table>" >> ${this_html}
    echo "</body>" >> ${this_html}
    echo "</html>" >> ${this_html}
  done
}

###############
# Start a job
###############
start_job() {
  if [ -s ${JOB_TRACKER} ] ; then
    HAVE_JOB="TRUE"
  else
    HAVE_JOB="FALSE"
  fi
  while [ "${HAVE_JOB}" == "FALSE" ]
  do
    sleep 5
    if [ -s ${JOB_TRACKER} ] ; then
      HAVE_JOB="TRUE"
    fi
  done
  job_number=$(flock ${JOB_TRACKER} -c "head -n 1 ${JOB_TRACKER} | cut -d':' -f2 ; sed -i '1d' ${JOB_TRACKER}")
  echo "${job_number}"
}

###############
# End a job
###############
end_job() {
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "JOB ENDING: ${1}"
  fi
  flock ${JOB_TRACKER} echo ":${1}:" >> ${JOB_TRACKER}
}

###############
# Wait for all jobs to finish
###############
wait_for_jobs() {
  job_queue_size="$(cat ${JOB_TRACKER} | wc -l )"
  while [ ${job_queue_size} -lt ${PARALLEL_JOBS} ]
  do
    # echo "WAITING FOR JOBS TO FINISH: ${job_queue_size} / ${PARALLEL_JOBS}"
    sleep 10
    job_queue_size="$(cat ${JOB_TRACKER} | wc -l )"
  done
}

###############
# Get our arguments
###############
while [[ "$#" -ge 1 ]]
do
key="$1"
case $key in
    --sync )
      export COMMAND="SYNC"
    ;;
    --check )
      export COMMAND="CHECK"
    ;;
    --build | --rebuild )
      export COMMAND="BUILD"
    ;;
    --double-check | --dc | --doublecheck )
      export COMMAND="DOUBLE_CHECK"
    ;;
    --check-modules | --checkmodules )
      export COMMAND="CHECK_MODULES"
    ;;
    -c | --checkout )
      export FED_GIT_CHECKOUT="${2}"
      shift
    ;;
    -bb | --brew-branch )
      export BREW_BRANCH="${2}"
      shift
    ;;
    -fd | --fed-dist )
      export FED_DIST="${2}"
      shift
    ;;
    -bd | --brew-dist )
      export BREW_DIST="${2}"
      shift
    ;;
    -m | --message )
      export CUSTOM_MESSAGE="${2}"
      shift
    ;;
    --yaml )
      export YAML_FILE="${2}"
      shift
    ;;
    --jobs )
      export PARALLEL_JOBS="${2}"
      shift
    ;;
    --text )
      export TEXT_FILE="${2}"
      shift
    ;;
    --no-remote | --noremote)
      export REMOTE="FALSE"
    ;;
    --brew-check | --brewcheck )
      export BREW_CHECK="TRUE"
    ;;
    -v | --verbose | --debug)
      export VERBOSE="TRUE"
    ;;
    -h | --help )
      usage
      exit 1
    ;;
    *)
      PACKAGE_LIST="${PACKAGE_LIST} ${key}"
    ;;
esac
shift # past argument or value
done

if [ "${SYNC_REMOTE}" == "" ] ; then
  export REMOTE="FALSE"
fi

###############
# parallel job setup
###############
rm -f ${JOB_TRACKER}
for ((i=1; i <= ${PARALLEL_JOBS} ; i++))
do
  echo ":${i}:" >> ${JOB_TRACKER}
done

if [ "${VERBOSE}" == "TRUE" ] ; then
  echo "COMMAND: ${COMMAND}"
  echo "WORKDIR: ${WORKDIR}"
  echo "OVERALL_TXT: ${OVERALL_TXT}"
  echo "OVERALL_HTML: ${OVERALL_HTML}"
  echo "FED_GIT_CHECKOUT: ${FED_GIT_CHECKOUT}"
  echo "FED_DIST: ${FED_DIST}"
  echo "BREW_BRANCH: ${BREW_BRANCH}"
  echo "BREW_DIST: ${BREW_DIST}"
  echo "BREW_CHECK: ${BREW_CHECK}"
  echo "PACKAGE_LIST: ${PACKAGE_LIST}"
  echo "CUSTOM_MESSAGE: ${CUSTOM_MESSAGE}"
  echo "LOGFILE: ${LOGFILE}"
  echo "YAML_FILE: ${YAML_FILE}"
  echo "TEXT_FILE: ${TEXT_FILE}"
  echo "REMOTE: ${REMOTE}"
  echo "SYNC_REMOTE: ${SYNC_REMOTE}"
  echo "PARALLEL_JOBS: ${PARALLEL_JOBS}"
fi

case "${COMMAND}" in
  SYNC )
    if [ "${BREW_BRANCH}" == "" ] ; then
      echo ; echo "ERROR: No brew branch given" ; echo
      usage
      exit 3
    fi
    if [ "${YAML_FILE}" == "" ] && [ "${TEXT_FILE}" == "" ] && [ "${PACKAGE_LIST}" == "" ]; then
      echo ; echo "ERROR: No packages or files given to process" ; echo
      usage
      exit 5
    fi
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping from remote area"
      rsync_in map
    fi
    echo "Gathering package information"
    get_packages | while read line
    do
      this_job=$(start_job)
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "JOB STARTING: ${this_job} LINE: ${line}"
      fi
      sync_distgit "newjob" ${this_job} "${line}" &
    done
    wait_for_jobs
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping to remote area"
      rsync_out map
    fi
  ;;
  CHECK )
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC FROM  REMOTE"
      rsync_in results
    fi
    echo "  START STATUS CHECK"
    cd ${WORKDIR}/logs
    build_list="$(ls -1 *.build 2>/dev/null)"
    if [ "${build_list}" == "" ] ; then
      echo "    No builds to process"
    else
      for build_log in ${build_list}
      do
        this_job=$(start_job)
        if [ "${VERBOSE}" == "TRUE" ] ; then
          echo "JOB STARTING: ${this_job} LOG: ${build_log}"
        fi
        check_build_status  ${this_job} ${build_log} &
      done
    fi
    wait_for_jobs
    echo "  END STATUS CHECK"
    # echo "  START STATUS WEB PAGE CREATION"
    # create_status_page
    # echo "  END STATUS WEB PAGE CREATION"
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC TO  REMOTE"
      rsync_out results
    fi
  ;;
  DOUBLE_CHECK )
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC FROM  REMOTE"
      rsync_in results
    fi
    echo "  START STATUS DOUBLE CHECK"
    # Save off our over pages once a day
    if ! [ -f ${OLD_OVERALL_TXT} ] ; then
      cp ${OVERALL_TXT} ${OLD_OVERALL_TXT}
      cp ${OVERALL_HTML} ${OLD_OVERALL_HTML}
    fi
    update_bootstrap_info
    # A Fresh overall and redlist file each time
    rm -f ${OVERALL_TXT}
    rm -f ${WEB_DIR}/RedList.txt
    touch ${WEB_DIR}/RedList.txt
    cd ${SCRIPT_HOME}
    export -f double_check_build_status
    export -f update_overall_status
    cd ${SCRIPT_HOME}
    brew -q list-pkgs --tag=rhel-8.0 | awk '{print $1}' | sort -u | grep -v -e devtoolset -e rhpkg-simple | xargs --max-procs=${PARALLEL_JOBS} -I THIS_PACKAGE \
      bash -c "double_check_build_status THIS_PACKAGE"

    # package_list="$(brew -q list-pkgs --tag=rhel-8.0-candidate | awk '{print $1}' | sort -u)"
    # if [ "${package_list}" == "" ] ; then
    #   echo "    No packages to process"
    # else
    #   for this_package in ${package_list}
    #   do
    #     this_job=$(start_job)
    #     if [ "${VERBOSE}" == "TRUE" ] ; then
    #       echo "JOB STARTING: ${this_job} LOG: ${build_log}"
    #     fi
    #     double_check_build_status  ${this_job} ${this_package} &
    #   done
    # fi
    # wait_for_jobs
    echo "  END STATUS DOUBLE CHECK"
    echo "  START STATUS WEB PAGE CREATION"
    create_status_page
    echo "  END STATUS WEB PAGE CREATION"
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC TO  REMOTE"
      rsync_out results
    fi
  ;;
  CHECK_MODULES )
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC FROM  REMOTE"
      rsync_in results
    fi
    echo "  START MODULES CHECK"
    check_module_status
    echo "  END MODULES CHECK"
    echo "  START STATUS WEB PAGE CREATION"
    create_modules_status_page
    echo "  END STATUS WEB PAGE CREATION"
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC TO  REMOTE"
      rsync_out results
    fi
  ;;
  BUILD )
    if [ "${BREW_BRANCH}" == "" ] || [ "${BREW_DIST}" == "" ] ; then
      echo ; echo "ERROR: No brew branch and/or brew dist given" ; echo
      usage
      exit 3
    fi
    if [ "${YAML_FILE}" == "" ] && [ "${TEXT_FILE}" == "" ] && [ "${PACKAGE_LIST}" == "" ]; then
      echo ; echo "ERROR: No packages or files given to process" ; echo
      usage
      exit 5
    fi
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping from remote area"
      rsync_in map
    fi
    echo "Gathering package information"
    get_packages | while read line
    do
      this_job=$(start_job)
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "JOB STARTING: ${this_job} LINE: ${line}"
      fi
      build_package ${this_job} "${line}" &
    done
    wait_for_jobs
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping to remote area"
      rsync_out map
    fi
  ;;
  * )
    echo ; echo "ERROR: A command must be given" ; echo
    usage
    exit 4
  ;;
esac

###############
# CLEANUP
###############
rm -f ${JOB_TRACKER} ${LOCK_FILE}

echo "Finished"
exit 0
